<html>
  <head>
    <title>&#11041;&#11042; hexile &#11043; </title>
  </head>


  <body style="background:black;margin:0;padding:0;">
    <div style="width:100%;">
      <canvas id="hexa"  height="600px" width="600px" style="margin:0 auto;width:600px;height:600px;background:rgb(139,241,181);">
      </canvas>
    </div>
    <script>
    //var types = ["zero","one","two60","two120","two180",
    //"three","three120","threeY1","threeY2",
    //"four60","four120","four180","five","six"];

    var types2 = [ [],    [0],    [0,1],[0,2],[0,3],
    [0,1,2],[0,2,4],[0,2,3],[0,1,3],
                    [0,1,2,3],[0,1,2,4],[0,1,3,4],
    [0,1,2,3,4],    [0,1,2,3,4,5]     ];


    var tiles = [];
    //types = ["three","three120","threeY1","threeY2"]; //validated zero one, six, five, twos
    var canvas = document.getElementById("hexa");
    var size = 20;
    var scale = 4;
    var spacing = 0;
    var ctx = canvas.getContext("2d");
    ctx.lineJoin = 'round';
    ctx.scale(scale,scale);
    //ctx.fillStyle = "#FF0000";
    //ctx.fillRect(0,0,150,75);
    var cols = 7; var rows = 7;
    var proba = 0.45;
    for (var col = 0 ; col < cols ; col++){
      var column = [];
      var limit = col%2==0?rows:rows-1;
      //limit =1;
      for (var row = 0 ; row < limit; row++){
        var type = types2[Math.floor(Math.random()*types2.length)];
        var rotation = 0;
        var tile = {type:type, rotation:rotation, col: col, row:row};
        column.push(tile);
      }
      tiles.push(column);
    }
    canvas.addEventListener('click', function(e) {
      var x;
        var y;
        if (e.pageX || e.pageY) {
        x = e.pageX;
        y = e.pageY;
        }
        else {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }
        x -= canvas.offsetLeft;
        y -= canvas.offsetTop;
        x/=scale;
        y/=scale;
        // detect which hexagon to rotate it
        for (var col = 0 ; col < tiles.length; col++){
          for (var row = 0 ; row < tiles[col].length; row++){
            if (x > xForCol(col,row,size) &&
              x< xForCol(col,row,size) +size &&
              y > yForRow(col,row,size) &&
              y< yForRow(col,row,size) + size
            ){
              //console.log("col " + col+ " row " + row);
              tiles[col][row].rotation = (tiles[col][row].rotation +1)%6;
              draw(tiles);
              var isDone = finished(tiles);
              if (isDone){
                alert("katcha");
                location.reload();
                console.log("########    DONE ########");
              }
            }
          }
        }
    }, false);

    generateOne(tiles);
    shuffle(tiles)
    draw(tiles);

    function shuffle(tiles){
      for (var col = 0 ; col < tiles.length; col++){
        for (var row = 0 ; row < tiles[col].length; row++){
          var tile = tiles[col][row];
          tile.rotation = Math.floor(Math.random()*6);
        }
      }
    }

    function arrayContainedIn(arrayOfArrays, array){
      for(var i = 0 ; i < arrayOfArrays.length ; i++){
        var current = arrayOfArrays[i];
        if (JSON.stringify(array)==JSON.stringify(current)) return true;
      }
      return false;
    }

    function isValid(col,row,tiles){
      if (col >= 0 && col < tiles.length){
        return row >= 0 && row < tiles[col].length;
      }
    }

    function draw(tiles){
      for (var col = 0 ; col < tiles.length; col++){
        for (var row = 0 ; row < tiles[col].length; row++){
          var tile = tiles[col][row];
          drawHexa(ctx, tile, xForCol(col,row,size), yForRow(col,row,size), size);
        }
      }
    }

    function xForCol(col,row, size){ return col* (size*3/4+spacing) ;}
    function yForRow(col,row, size){ return row* (size+spacing) + (col%2==0?0:size/2);}

    function getHexa(startX, startY, size){
      return [
        {x:startX+(3*size/4),   y:startY},
        {x:startX+size,       y:startY+size/2},
        {x:startX+(3*size/4),   y:startY+size},
        {x:startX+size/4,     y:startY+size},
        {x:startX,            y:startY +size/2} ,
        {x:startX+size/4,     y:startY}
      ];
    }

    function showCon(tile){
      var line = "";
      for (var pos = 0 ; pos < 6 ; pos++){
        line += isOn(tile.type, tile.rotation+1, pos)?pos:".";
      }
      return line;
    }

    function finished(tiles){
      for (var col = 0 ; col < tiles.length; col++){
        for (var row = 0 ; row < tiles[col].length; row++){
          var rotated  = rotate(tiles[col][row].type,tiles[col][row].rotation);

          console.log("col "+col+" row "+row+ " :: " + showCon(tiles[col][row]) );
          // bottom
          if (isValid(col, row+1, tiles) ){
            console.log("  >> below  :: " + showCon(tiles[col][row+1]) );
            var me =     showCon(tiles[col][row]).indexOf(3) >-1;
            var other =  showCon(tiles[col][row+1]).indexOf(0) > -1;
            // return false if one is on and the other if off   XOR
            if (me?!other:other) return false;
          }
          // the tile on the right bottom for even cols
          if (col%2==0 && isValid(col+1, row, tiles) ){
            console.log("  >> rightb :: " + showCon(tiles[col+1][row]) );
            var me = showCon(tiles[col][row]).indexOf(2) >-1;
            var other =  showCon(tiles[col+1][row]).indexOf(5) > -1;
            // return false if one is on and the other if off   XOR
            if (me?!other:other) return false;
          }
          // the tile on the right bottom for odd cols
          if (col%2==1 && isValid(col+1, row+1, tiles) ){
            console.log("  >> rightb :: " + showCon(tiles[col+1][row+1]) );
            var me = showCon(tiles[col][row]).indexOf(2) >-1;
            var other =  showCon(tiles[col+1][row+1]).indexOf(5) > -1;
            // return false if one is on and the other if off   XOR
            if (me?!other:other) return false;
          }
          // the tile on the right top for even cols
          if (col%2==0 && isValid(col+1, row-1, tiles)){
            console.log("  >> rightt :: " + showCon(tiles[col+1][row-1]) );
            var me = showCon(tiles[col][row]).indexOf(1) >-1;
            var other =  showCon(tiles[col+1][row-1]).indexOf(4) > -1;
            // return false if one is on and the other if off   XOR
            if (me?!other:other) return false;
          }
          // the tile on the right top for odd cols
          if (col%2==1 && isValid(col+1, row, tiles)){
            console.log("  >> rightt :: " + showCon(tiles[col+1][row]) );
            var me = showCon(tiles[col][row]).indexOf(1) >-1;
            var other =  showCon(tiles[col+1][row]).indexOf(4) > -1;
            // return false if one is on and the other if off   XOR
            if (me?!other:other) return false;
          }
          // if there is a pos but no neighbour
          if (!isValid(col, row-1, tiles) && showCon(tiles[col][row]).indexOf(0) >-1) return false;
          if (!isValid(col, row+1, tiles) && showCon(tiles[col][row]).indexOf(3) >-1) return false;
          if (col%2==0 && !isValid(col+1, row-1, tiles) && showCon(tiles[col][row]).indexOf(1) >-1) return false;
          if (col%2==1 && !isValid(col+1, row, tiles) && showCon(tiles[col][row]).indexOf(1) >-1) return false;
          if (col%2==0 && !isValid(col+1, row, tiles) && showCon(tiles[col][row]).indexOf(2) >-1) return false;
          if (col%2==1 && !isValid(col+1, row+1, tiles) && showCon(tiles[col][row]).indexOf(2) >-1) return false;
          if (col%2==0 && !isValid(col-1, row, tiles) && showCon(tiles[col][row]).indexOf(4) >-1) return false;
          if (col%2==1 && !isValid(col-1, row+1, tiles) && showCon(tiles[col][row]).indexOf(4) >-1) return false;
          if (col%2==0 && !isValid(col-1, row-1, tiles) && showCon(tiles[col][row]).indexOf(5) >-1) return false;
          if (col%2==1 && !isValid(col-1, row, tiles) && showCon(tiles[col][row]).indexOf(5) >-1) return false;
          //console.log("No trouble for  col " + col + " row " + row);
        }
      }
      return true;
    }

    function generateOne(tiles){
      var connectors = [];
      for (var col = 0 ; col < tiles.length; col++){
        var coll = [];
        for (var row = 0 ; row < tiles[col].length; row++){
          coll.push([]);
        }
        connectors.push(coll);
      }
      //showConnectors(connectors);
      // randomly choose if two tiles are connected

      for (var col = 0 ; col < tiles.length; col++){
        for (var row = 0 ; row < tiles[col].length; row++){

          // the tile under
          if (isValid(col, row+1, tiles) && Math.random() < proba){
            connectors[col][row].push(3);
            connectors[col][row+1].push(0);
          }
          // the tile on the right bottom for even cols
          if (col%2==0 && isValid(col+1, row, tiles) && Math.random() < proba){
            connectors[col][row].push(2);
            connectors[col+1][row].push(5);
          }
          // the tile on the right bottom for odd cols
          if (col%2==1 && isValid(col+1, row+1, tiles) && Math.random() < proba){
            connectors[col][row].push(2);
            connectors[col+1][row+1].push(5);
          }
          // the tile on the right top for even cols
          if (col%2==0 && isValid(col+1, row-1, tiles) && Math.random() < proba){
            connectors[col][row].push(1);
            connectors[col+1][row-1].push(4);
          }
          // the tile on the right top for odd cols
          if (col%2==1 && isValid(col+1, row, tiles) && Math.random() < proba){
            connectors[col][row].push(1);
            connectors[col+1][row].push(4);
          }
        }
      }
      //showConnectors(connectors);
      update(connectors, tiles);
      draw(tiles);
    }

    // replace tiles with the good type and fixes rotation to give actual solution
    function update(connectors, tiles){
      for (var col = 0 ; col < tiles.length; col++){
        for (var row = 0 ; row < tiles[col].length; row++){
          for (var rot = 0 ; rot < 6 ; rot++){
            var rotated = rotate(connectors[col][row],rot);
            if (arrayContainedIn(types2, rotated) > -1){
              tiles[col][row].type = rotate(connectors[col][row],rot);
              tiles[col][row].rotation = (7+rot)%6;
            }
          }
        }
      }
    }

    function showConnectors(connectors){
      var res = ""
      for (var row = 0 ; row < connectors[0].length+2; row++){
        var line = "";
        for (var col = 0 ; col < connectors.length; col++){
          line += "  ";
          for (var pos = 0 ; pos < 6 ; pos++){
            if (isValid(col, row, tiles)){
              if (connectors[col][row].indexOf(pos) > -1){
                line+= pos;
              }
              else{
                line+= ".";
              }
            }
          }
        }
        res += line+"\n";
      }
      console.log(res);
    }

    function drawHexa(ctx, tile, startX, startY, size){
      //console.log("type " + tile.type + " rotation : "+ tile.rotation );
      var positions = getHexa(startX, startY, size);
      var c2 = ctx;
      // draw the hexagon

      c2.fillStyle = 'rgb(139,241,181)';
      c2.strokeStyle = 'rgb(129,231,171)';
      c2.beginPath();
      c2.moveTo(startX+size/4, startY);
      c2.lineTo(startX, startY +size/2);
      c2.lineTo(startX+size/4, startY+size);
      c2.lineTo(startX+3*size/4, startY+size);
      c2.lineTo(startX+size, startY+size/2);
      c2.lineTo(startX+3*size/4,startY);
      c2.closePath();
      c2.fill();
      c2.stroke();
      //console.log("Y : "+startY + " :: "+ (startY+size)  + "    X "+ startX +" :: " + (startX+size));
      for (var pos = 0 ; pos < 6 ; pos++){
        var ison = isOn(tile.type, tile.rotation, pos );
        //console.log(" >> pos " + pos + " ::: " + ison);
        if (ison){
          c2.strokeStyle = 'rgb(213,99,82)';
          c2.beginPath();
          c2.moveTo(startX+size/2, startY+size/2);
          var xx = (positions[pos].x + positions[(pos+1)%6].x) /2;
          var yy = (positions[pos].y + positions[(pos+1)%6].y) /2;
          c2.lineTo(xx, yy);
          c2.stroke();
        }
      }
      if (tile.type.length > 0){
        c2.fillStyle = 'rgb(163,49,32)';
        c2.beginPath();
        c2.arc(startX+size/2, startY+size/2, (tile.type.length==1?size/6:1), 0, 2 * Math.PI, false);
        c2.fill();
      }

    }

    function rotate(tile, rotation){
      var res = tile.slice();
      for (var r = 0 ; r< rotation ; r++){
        for (var elt = 0 ; elt < res.length ; elt++){
          res[elt] = (res[elt]+1)%6;
        }
      }
      return res;
    }

    function isOn(type, rotation, position){
      return rotate(type, rotation).indexOf(position) > -1;
    }

    /*function isOn(type, rotation, position){
      if (type === "zero") return false;
      if (type === "one") return rotation == position;

      if (type === "two60") return rotation == position || rotation == (position+1)%6;
      if (type === "two120") return rotation == position || rotation == (position+2)%6;
      if (type === "two180") return rotation == position || rotation == (position+3)%6;

      if (type === "three") return rotation == position || rotation == (position+1)%6 || rotation == (position+2)%6;
      if (type === "three120") return rotation == position || rotation == (position+2)%6 || rotation == (position+4)%6;
      if (type === "threeY1") return rotation == position || rotation == (position+1)%6 || rotation == (position+3)%6;
      if (type === "threeY2") return rotation == position || rotation == (position+1)%6 || rotation == (position+4)%6;

      if (type === "four60") return !(rotation == position || rotation == (position+1)%6);
      if (type === "four120") return !(rotation == position || rotation == (position+2)%6);
      if (type === "four180") return !(rotation == position || rotation == (position+3)%6);

      if (type === "five") return rotation != position;
      if (type === "six") return true;
    }*/

    </script>
  </body>

</html>
